# CreateAgent_and_ToT

## 任务一：实现一个基础通用对话Agent
### 1.任务流程
![demo](demo.png)
### 2.设计思路
2.1 设计一个模可插拔的模型接口，允许调用不同的模型<br>
2.2 设计临时数据存储库：State<br>
2.3 设计提示词：Prompt<br>
2.4 设计可使用工具：Tool<br>
2.5 设计输入输出限制：Pydantic<br>
2.5 设计各个节点：Node<br>
2.6 设计各个边，包括单向边、双向边、判断边<br>
2.7 设计长久记忆模块，假如有需要长久记忆的就放进去<br>
2.8 设计用户线程，保证多轮对话下，使用的是同一个State，允许用户进行多轮对话<br>

## 任务二： Game of 24（24点游戏）
### 1. 设计思路
1.1 设计思维树<br>
1.1.1 思维状态定义：将当前剩余的数字列表定义为一个“状态”。例如，初始状态为 [3, 3, 8, 8]。每一次“思维步”是从列表中任选两个数 $a, b$，进行四则运算得到 $c$，将 $a, b$ 移除并存入 $c$，形成新状态（长度减 1）。当状态中只剩一个数字且等于 24 时，任务完成。<br>
1.1.2 搜索树前2层结构（以 [3, 8] 为例）：<br>
- Level 0: [3, 8]<br>
- Level 1:[11] (通过3+8) ，[5] (通过8-3) ，[24] (通过3*8) ，[0.375] (通过3/8)<br>
1.1.3 避免重复搜索：<br>
- 状态排序：对列表中的数字进行排序后存入 set（如 (3, 8) 与 (8, 3) 视为同一状态）。<br>
- 记忆化：记录已访问过的数字组合，若再次遇到则跳过。<br>

1.2 评估函数 evaluate(state)评估标准：<br>
确定性：若剩余数字通过简单运算能直接得到 24，分值为 1.0。<br>
潜力值：检查剩余数字是否能通过因子分解（如 24 的约数 2, 3, 4, 6, 8, 12）靠近目标。<br>
可行性：排除明显无法凑成整数或超出合理范围的状态。<br>
计算公式：![demo](calu.png)<br>

1.3 搜索策略选择 BFS (Breadth-First Search)。<br>
理由：24点游戏的树深度固定且很浅（最多 3 步运算）。<br>
BFS 能够层级化地评估所有可能性，配合 Beam Search（束搜索） 可以有效控制每一层的状态数量，优先保留评估分数高的状态。<br>
